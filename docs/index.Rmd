---
title: 'Collapsible Tree Example: R Markdown'
author: "Adeel Khan"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(collapsibleTree)
df <- read.csv("GeographyTable.csv")
```

## Overview

collapsibleTree is an R htmlwidget that allows you to create interactive collapsible Reingoldâ€“Tilford tree diagram using D3.js. Turn your data frame into a hierarchical visualization without worrying about nested lists or JSON objects!
  
If you're using Shiny, you can bind the most recently clicked node to a Shiny input, allowing for easier interaction with complex nested objects. The input will return a named list containing the most recently selected node, as well as all of its parents. See the Shiny example for more info.

## Data frames, not lists

When working with data in R, it makes sense (at least to me) to represent everything as a data frame. I'm a big fan of [tidy data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html), but this structure does not lend itself to easily designing hierarchical networks. 

collapsibleTree uses [data.tree](https://cran.r-project.org/web/packages/data.tree/vignettes/data.tree.html) to handle all of that, freeing you from a lot of recursive list construction.

Here is an example geography dataset from [data.world](https://data.world/glx/geography-table):

```{r summary}
summary(df)
```

## Rendering the plot

With your data frame in hand, and a vector of columns to graph, creating an interactive collapsible tree diagram can be done like so:

```{r plot}
collapsibleTree(
  df,
  hierarchy = c("continent", "type", "country"),
  root = "Geography",
  width = 800
)
```

## Adding Colors

You can add colors to each node in the diagram manually by declaring a `fill` value. Fill is declared as a hierarchy, applied down the tree. In order to get your vectors to the right length for complex trees (this one has 385 nodes), you could use a pattern like this:

```{r plotcolored}
collapsibleTree(
  df,
  hierarchy = c("continent", "type", "country"),
  root = "Geography",
  width = 800,
  fill = c(
    # The root
    "white",
    # Unique continents
    rep("firebrick", length(unique(df$continent))),
    # Unique types per continent
    rep("steelblue", length(unique(paste(df$continent, df$type)))),
    # Unique countries
    rep("green", length(unique(df$country)))
  )
)
```

## Using Gradients

Throw in some gradients if you'd like! Each node can have its own distinct color. Let's use some `dplyr` to help us with the data aggregation and use `RColorBrewer` and `colorspace` to make some nice looking palettes.

The fill order is depends on the order of the data frame. This time we'll sort alphabetically rather than using the order the dataset originally came in.

```{r plotgradient, warning=FALSE}
library(dplyr, warn.conflicts = FALSE)

# Continents are a simple gradient
continentColors <- RColorBrewer::brewer.pal(length(unique(df$continent)), "Reds")
# Types will be a gradient that resets between continents
typeColors <- df %>%
  arrange(continent, type) %>% 
  group_by(continent) %>%
  distinct(type) %>%
  mutate(colors=colorspace::sequential_hcl(length(type))[seq_along(type)])
# Countries will also be a gradient that resets between continents, but not types
countryColors <- df %>%
  arrange(continent, type) %>% 
  group_by(continent) %>%
  distinct(country) %>%
  mutate(colors=colorspace::rainbow_hcl(length(country))[seq_along(country)])

df %>%
  arrange(continent ,type, country) %>%
collapsibleTree(
  hierarchy = c("continent", "type", "country"),
  root = "Geography",
  width = 800,
  fill = c("white", continentColors, typeColors$colors, countryColors$colors)
)
```
